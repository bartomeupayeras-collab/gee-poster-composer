<!doctype html>
<html lang="ca">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>GEE Poster Composer · 1 o 3 mapes</title>
  <style>
    :root { --panel-w: 360px; --bg:#0b0f14; --panel:#121824; --text:#e7eefc; --muted:#93a4c7; --line:#233046; --btn:#1e2a3f; --warn:#ffcc66; --ok:#76e39a; }
    * { box-sizing:border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .app { display:grid; grid-template-columns: var(--panel-w) 1fr; min-height:100vh; }
    .panel { padding:16px; background:var(--panel); border-right:1px solid var(--line); overflow:auto; }
    .panel h1 { font-size:16px; margin:0 0 8px; }
    .panel .sub { font-size:12px; color:var(--muted); margin:0 0 14px; line-height:1.35; }
    .group { border:1px solid var(--line); border-radius:12px; padding:12px; margin:10px 0; background:rgba(255,255,255,0.02); }
    .group h2 { font-size:13px; margin:0 0 10px; color:#cfe0ff; }
    label { display:block; font-size:12px; color:var(--muted); margin:8px 0 4px; }
    input[type="text"], textarea, select { width:100%; padding:10px 10px; border-radius:10px; border:1px solid var(--line); background:#0f1522; color:var(--text); }
    textarea { min-height:60px; resize:vertical; }
    input[type="range"] { width:100%; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .btnbar { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button { cursor:pointer; border:1px solid var(--line); background:var(--btn); color:var(--text); padding:10px 12px; border-radius:10px; font-weight:600; }
    button:hover { filter:brightness(1.06); }
    .status { font-size:12px; color:var(--muted); margin-top:8px; line-height:1.35; }
    .status .ok { color:var(--ok); font-weight:700; }
    .status .warn { color:var(--warn); font-weight:700; }
    .stage { display:flex; align-items:center; justify-content:center; padding:18px; }
    canvas { background:#fff; border-radius:14px; box-shadow:0 10px 35px rgba(0,0,0,.45); max-width:calc(100vw - var(--panel-w) - 36px); max-height:calc(100vh - 36px); }
    .hint { font-size:12px; color:var(--muted); margin-top:6px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:rgba(255,255,255,0.06); border:1px solid var(--line); font-size:11px; color:#cfe0ff; }
  </style>
</head>
<body>
<div class="app">
  <div class="panel">
    <h1>Composer (definitiu) · 1 o 3 mapes</h1>
    <p class="sub">
      Llegeix <span class="pill">?p=</span> (JSON) i renderitza 1 o 3 mapes.
      Llegenda <b>lliure</b>: arrossega-la o usa sliders X/Y.
      <br/>Layout: <b>3 columnes</b> si el format és horitzontal, <b>apilat</b> si és vertical.
    </p>

    <div class="group">
      <h2>Format</h2>
      <label>Mida del canvas</label>
      <select id="formatSelect">
        <option value="1600x900">16:9 (1600×900)</option>
        <option value="1920x1080">16:9 (1920×1080)</option>
        <option value="2400x1350">16:9 (2400×1350)</option>
        <option value="3508x2480">A4 horitzontal (3508×2480)</option>
        <option value="2480x3508">A4 vertical (2480×3508)</option>
      </select>
      <div class="hint">Consell: A4 (3508×2480) és 300 dpi.</div>
    </div>

    <div class="group">
      <h2>Títol</h2>
      <label>Títol</label>
      <input id="titleInput" type="text" placeholder="Títol"/>
      <label>Subtítol</label>
      <textarea id="subtitleInput" placeholder="Subtítol"></textarea>
    </div>

    <div class="group">
      <h2>Llegenda lliure</h2>
      <label>Mode</label>
      <select id="legendMode">
        <option value="free">Lliure (drag + X/Y)</option>
        <option value="right">Dreta</option>
        <option value="left">Esquerra</option>
        <option value="off">Amagar</option>
      </select>
      <div class="row">
        <div>
          <label>X</label>
          <input id="legendX" type="range" min="0" max="1000" value="40"/>
        </div>
        <div>
          <label>Y</label>
          <input id="legendY" type="range" min="0" max="1000" value="40"/>
        </div>
      </div>
      <div class="hint">Arrossega la llegenda directament damunt el canvas.</div>
    </div>

    <div class="group">
      <h2>Accions</h2>
      <div class="btnbar">
        <button id="btnRender">Redibuixar</button>
        <button id="btnDownload">Descarregar PNG</button>
        <button id="btnResetLegend">Reset llegenda</button>
      </div>
      <div id="status" class="status"></div>
    </div>

    <div class="group">
      <h2>Debug</h2>
      <div class="hint">Si alguna cosa falla, mira la consola del navegador (F12).</div>
      <div class="hint">Claus útils: <span class="pill">payload.maps</span>, <span class="pill">dataUrl</span>, <span class="pill">palette/min/max/unit</span>.</div>
    </div>
  </div>

  <div class="stage">
    <canvas id="c" width="1600" height="900"></canvas>
  </div>
</div>

<script>
/** -------------------------------------------------------
 *  Helpers
 * ------------------------------------------------------*/
const qsRaw = (k) => {
  // keep '+' intact by manual parsing
  const q = location.search.startsWith('?') ? location.search.slice(1) : location.search;
  const parts = q.split('&').filter(Boolean);
  for (const part of parts) {
    const idx = part.indexOf('=');
    const key = idx >= 0 ? part.slice(0, idx) : part;
    if (key === k) return idx >= 0 ? part.slice(idx+1) : '';
  }
  return null;
};

function safeDecodeURIComponent(str){
  try { return decodeURIComponent(str); } catch(e) { return str; }
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function parsePayload(){
  const raw = qsRaw('p');
  if(!raw) return null;

  // We expect classic: encodeURIComponent(JSON.stringify(payload))
  const decoded = safeDecodeURIComponent(raw);
  // If someone accidentally passes base64, ignore here (we build for classic).
  try { return JSON.parse(decoded); } catch(e) {
    console.warn("JSON.parse failed on decoded ?p=. First 200 chars:", decoded.slice(0,200));
    return null;
  }
}

function normalizeMaps(payload){
  if(!payload) return { maps: [] };
  // Accept payload.dataUrl as single-map legacy
  let maps = Array.isArray(payload.maps) ? payload.maps : [];
  if(!maps.length && payload.dataUrl){
    maps = [{ dataUrl: payload.dataUrl, title: payload.mapTitle || payload.title || '' }];
  }
  // Normalize each map object
  maps = maps.map((m, i) => ({
    dataUrl: m.dataUrl || m.url || m.thumb || "",
    title: m.title || m.label || (i===0?"Mapa A": i===1?"Mapa B":"Mapa Δ"),
    palette: m.palette || (payload.palette || null),
    min: (m.min ?? payload.min ?? null),
    max: (m.max ?? payload.max ?? null),
    unit: (m.unit ?? payload.unit ?? ""),
  }));
  return { ...payload, maps };
}

function loadImage(url){
  return new Promise((resolve, reject) => {
    if(!url) return reject(new Error("Empty image URL"));
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = () => reject(new Error("Failed to load image: " + url.slice(0,120)));
    img.src = url;
  });
}

function drawRoundedRect(ctx, x,y,w,h,r){
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

function parsePalette(p){
  if(!p) return null;
  if(Array.isArray(p)) return p;
  if(typeof p === 'string'){
    // Accept "a,b,c" or JSON-like '["#.."]'
    try{
      const j = JSON.parse(p);
      if(Array.isArray(j)) return j;
    }catch(e){}
    return p.split(',').map(s => s.trim()).filter(Boolean);
  }
  return null;
}

function setStatus(msg, kind){
  const el = document.getElementById('status');
  el.innerHTML = msg ? msg : '';
  if(kind === 'ok') el.innerHTML = '<span class="ok">OK</span> ' + el.innerHTML;
  if(kind === 'warn') el.innerHTML = '<span class="warn">ATENCIÓ</span> ' + el.innerHTML;
}

/** -------------------------------------------------------
 *  Layout
 * ------------------------------------------------------*/
function isLandscape(canvas){ return canvas.width >= canvas.height; }

function computeLayout(canvas, mapCount){
  const W = canvas.width, H = canvas.height;
  const margin = Math.round(Math.min(W,H) * 0.03); // 3%
  const headerH = Math.round(H * 0.10);
  const labelH = Math.round(H * 0.035);
  const innerTop = margin + headerH;
  const innerLeft = margin;
  const innerRight = W - margin;
  const innerBottom = H - margin;

  const innerW = innerRight - innerLeft;
  const innerH = innerBottom - innerTop;

  let slots = [];
  if(mapCount <= 1){
    const x = innerLeft;
    const y = innerTop + labelH;
    const w = innerW;
    const h = innerH - labelH;
    slots = [{ x, y, w, h, labelX: x, labelY: innerTop, labelW: w, labelH }];
  } else {
    if(isLandscape(canvas)){
      // 3 columns
      const gap = Math.round(innerW * 0.02);
      const colW = Math.floor((innerW - 2*gap) / 3);
      for(let i=0;i<3;i++){
        const x = innerLeft + i*(colW+gap);
        const y = innerTop + labelH;
        const w = colW;
        const h = innerH - labelH;
        slots.push({ x, y, w, h, labelX:x, labelY:innerTop, labelW:w, labelH });
      }
    } else {
      // stacked
      const gap = Math.round(innerH * 0.02);
      const rowH = Math.floor((innerH - 2*gap) / 3);
      for(let i=0;i<3;i++){
        const x = innerLeft;
        const y = innerTop + i*(rowH+gap) + labelH;
        const w = innerW;
        const h = rowH - labelH;
        const labelY = innerTop + i*(rowH+gap);
        slots.push({ x, y, w, h, labelX:x, labelY, labelW:w, labelH });
      }
    }
  }

  return { margin, headerH, slots, innerLeft, innerTop, innerW, innerH };
}

/** -------------------------------------------------------
 *  Legend (free drag + sliders)
 * ------------------------------------------------------*/
const legendState = {
  x: 40,
  y: 40,
  w: 280,
  h: 170,
  dragging: false,
  dragDx: 0,
  dragDy: 0
};

function legendDefaultSize(canvas){
  const base = Math.min(canvas.width, canvas.height);
  legendState.w = Math.round(base * 0.20);
  legendState.h = Math.round(base * 0.14);
}

function legendBounds(canvas){
  return {
    minX: 0,
    minY: 0,
    maxX: canvas.width - legendState.w,
    maxY: canvas.height - legendState.h
  };
}

function slidersToLegend(canvas){
  const xSlider = document.getElementById('legendX');
  const ySlider = document.getElementById('legendY');
  legendState.x = clamp(parseInt(xSlider.value,10) || 0, 0, legendBounds(canvas).maxX);
  legendState.y = clamp(parseInt(ySlider.value,10) || 0, 0, legendBounds(canvas).maxY);
}

function legendToSliders(canvas){
  const xSlider = document.getElementById('legendX');
  const ySlider = document.getElementById('legendY');
  xSlider.max = Math.max(0, canvas.width - legendState.w);
  ySlider.max = Math.max(0, canvas.height - legendState.h);
  xSlider.value = clamp(Math.round(legendState.x), 0, xSlider.max);
  ySlider.value = clamp(Math.round(legendState.y), 0, ySlider.max);
}

function pointInLegend(px, py){
  return (px >= legendState.x && px <= legendState.x + legendState.w &&
          py >= legendState.y && py <= legendState.y + legendState.h);
}

function drawLegend(ctx, canvas, payload){
  const mode = document.getElementById('legendMode').value;
  if(mode === 'off') return;

  // Determine anchor position if left/right
  if(mode === 'left' || mode === 'right'){
    const pad = Math.round(Math.min(canvas.width, canvas.height) * 0.03);
    legendState.y = pad + Math.round(canvas.height * 0.10) + 10; // below header
    legendState.x = (mode === 'left') ? pad : (canvas.width - pad - legendState.w);
    legendToSliders(canvas);
  }

  const maps = payload.maps || [];
  const hasDiff = maps.length >= 3;

  // palette: map0 palette for normal legend, map2 palette for diff if present & different
  const p0 = parsePalette(maps[0]?.palette || payload.palette || null);
  const p2 = parsePalette(maps[2]?.palette || payload.diffPalette || null);
  const paletteMain = p0 || ["#1a9850","#66bd63","#a6d96a","#d9ef8b","#ffffbf","#fee08b","#fdae61","#f46d43","#d73027"];
  const paletteDiff = p2 || ["#2c7bb6","#abd9e9","#ffffbf","#fdae61","#d7191c"];

  const min0 = (maps[0]?.min ?? payload.min ?? "");
  const max0 = (maps[0]?.max ?? payload.max ?? "");
  const unit0 = (maps[0]?.unit ?? payload.unit ?? "");

  const min2 = (maps[2]?.min ?? payload.diffMin ?? "");
  const max2 = (maps[2]?.max ?? payload.diffMax ?? "");
  const unit2 = (maps[2]?.unit ?? payload.diffUnit ?? unit0);

  const r = 12;
  ctx.save();
  ctx.globalAlpha = 0.96;
  drawRoundedRect(ctx, legendState.x, legendState.y, legendState.w, legendState.h, r);
  ctx.fillStyle = "rgba(15,21,34,0.92)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 1;
  ctx.stroke();
  ctx.globalAlpha = 1;

  const pad = 12;
  let x = legendState.x + pad;
  let y = legendState.y + pad;

  ctx.fillStyle = "#e7eefc";
  ctx.font = "600 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.textBaseline = "top";
  ctx.fillText("Llegenda", x, y);
  y += 20;

  // Main legend bar
  const barH = 10;
  const barW = legendState.w - 2*pad;
  const grad = ctx.createLinearGradient(x, y, x + barW, y);
  const pal = paletteMain;
  for(let i=0;i<pal.length;i++){
    const t = pal.length===1 ? 0 : i/(pal.length-1);
    grad.addColorStop(t, pal[i]);
  }
  ctx.fillStyle = grad;
  ctx.fillRect(x, y, barW, barH);
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.strokeRect(x, y, barW, barH);
  y += barH + 6;

  ctx.fillStyle = "rgba(231,238,252,0.85)";
  ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  const leftTxt = (min0 !== "" && min0 !== null) ? String(min0) : "";
  const rightTxt = (max0 !== "" && max0 !== null) ? String(max0) : "";
  ctx.fillText(leftTxt, x, y);
  const rtW = ctx.measureText(rightTxt).width;
  ctx.fillText(rightTxt, x + barW - rtW, y);
  y += 16;
  if(unit0){
    ctx.fillStyle = "rgba(147,164,199,0.9)";
    ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(String(unit0), x, y);
    y += 14;
  } else {
    y += 6;
  }

  if(hasDiff){
    // divider
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.beginPath();
    ctx.moveTo(x, y+6);
    ctx.lineTo(x+barW, y+6);
    ctx.stroke();
    y += 14;

    ctx.fillStyle = "#cfe0ff";
    ctx.font = "600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("Δ (B–A)", x, y);
    y += 18;

    const grad2 = ctx.createLinearGradient(x, y, x + barW, y);
    const pal2 = paletteDiff;
    for(let i=0;i<pal2.length;i++){
      const t = pal2.length===1 ? 0 : i/(pal2.length-1);
      grad2.addColorStop(t, pal2[i]);
    }
    ctx.fillStyle = grad2;
    ctx.fillRect(x, y, barW, barH);
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.strokeRect(x, y, barW, barH);
    y += barH + 6;

    ctx.fillStyle = "rgba(231,238,252,0.85)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const leftTxt2 = (min2 !== "" && min2 !== null) ? String(min2) : "";
    const rightTxt2 = (max2 !== "" && max2 !== null) ? String(max2) : "";
    ctx.fillText(leftTxt2, x, y);
    const rtW2 = ctx.measureText(rightTxt2).width;
    ctx.fillText(rightTxt2, x + barW - rtW2, y);
  }

  ctx.restore();
}

/** -------------------------------------------------------
 *  Render
 * ------------------------------------------------------*/
let CURRENT_PAYLOAD = null;
let CURRENT_IMAGES = [];

async function render(){
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const rawPayload = parsePayload();
  if(!rawPayload){
    setStatus("No s'ha trobat un payload vàlid a ?p=. Torna al visor i fes export.", "warn");
    ctx.clearRect(0,0,canvas.width,canvas.height);
    return;
  }
  const payload = normalizeMaps(rawPayload);
  CURRENT_PAYLOAD = payload;

  // Apply title/subtitle from payload if empty
  const titleEl = document.getElementById('titleInput');
  const subEl = document.getElementById('subtitleInput');
  if(!titleEl.value && payload.title) titleEl.value = payload.title;
  if(!subEl.value && payload.subtitle) subEl.value = payload.subtitle;

  // Update canvas size
  const fmt = document.getElementById('formatSelect').value.split('x').map(n=>parseInt(n,10));
  canvas.width = fmt[0]; canvas.height = fmt[1];

  // Legend sizing & sliders bounds
  legendDefaultSize(canvas);
  legendToSliders(canvas);
  slidersToLegend(canvas);

  // Load map images
  const maps = payload.maps || [];
  const needed = (maps.length >= 3) ? 3 : 1;
  const urls = maps.slice(0, needed).map(m => m.dataUrl).filter(Boolean);

  if(urls.length !== needed){
    setStatus("Payload incomplet: falten URLs de mapa (getThumbURL). Revisa payload.maps[].dataUrl.", "warn");
    console.warn("Payload maps:", maps);
    return;
  }

  setStatus("Carregant mapes…", "ok");
  try{
    CURRENT_IMAGES = await Promise.all(urls.map(loadImage));
  }catch(e){
    setStatus("Error carregant imatge: " + (e?.message || e), "warn");
    console.error(e);
    return;
  }

  // Draw background
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Header
  const layout = computeLayout(canvas, needed);
  const title = titleEl.value || "";
  const subtitle = subEl.value || "";
  const margin = layout.margin;

  ctx.fillStyle = "#0f1522";
  ctx.fillRect(0,0,canvas.width, margin + layout.headerH);

  ctx.fillStyle = "#e7eefc";
  ctx.font = "700 " + Math.round(canvas.height*0.030) + "px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.textBaseline = "top";
  ctx.fillText(title, margin, margin);

  ctx.fillStyle = "rgba(231,238,252,0.82)";
  ctx.font = "400 " + Math.round(canvas.height*0.018) + "px system-ui, -apple-system, Segoe UI, Roboto, Arial";
  wrapText(ctx, subtitle, margin, margin + Math.round(canvas.height*0.040), canvas.width - 2*margin, Math.round(canvas.height*0.022), 3);

  // Map labels + maps
  for(let i=0;i<needed;i++){
    const slot = layout.slots[i];
    const label = (payload.maps[i]?.title) || (i===0?"Mapa A": i===1?"Mapa B":"Δ (B–A)");

    // label
    ctx.fillStyle = "rgba(15,21,34,0.85)";
    drawRoundedRect(ctx, slot.labelX, slot.labelY, slot.labelW, slot.labelH, 10);
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.stroke();

    ctx.fillStyle = "#e7eefc";
    ctx.font = "600 " + Math.round(canvas.height*0.016) + "px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textBaseline = "middle";
    ctx.fillText(label, slot.labelX + 10, slot.labelY + slot.labelH/2);

    // map image in slot
    ctx.save();
    drawRoundedRect(ctx, slot.x, slot.y, slot.w, slot.h, 14);
    ctx.clip();
    // cover fit
    const img = CURRENT_IMAGES[i];
    const scale = Math.max(slot.w / img.width, slot.h / img.height);
    const dw = img.width * scale;
    const dh = img.height * scale;
    const dx = slot.x + (slot.w - dw)/2;
    const dy = slot.y + (slot.h - dh)/2;
    ctx.drawImage(img, dx, dy, dw, dh);
    ctx.restore();

    // border
    ctx.strokeStyle = "rgba(15,21,34,0.25)";
    ctx.lineWidth = 2;
    drawRoundedRect(ctx, slot.x, slot.y, slot.w, slot.h, 14);
    ctx.stroke();
  }

  // Legend
  drawLegend(ctx, canvas, payload);

  setStatus("Render complet ("+needed+" mapes).", "ok");
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight, maxLines){
  if(!text) return;
  const words = String(text).split(/\s+/);
  let line = "";
  let lines = 0;
  for(let n=0;n<words.length;n++){
    const testLine = line ? (line + " " + words[n]) : words[n];
    const metrics = ctx.measureText(testLine);
    if(metrics.width > maxWidth && line){
      ctx.fillText(line, x, y + lines*lineHeight);
      line = words[n];
      lines++;
      if(maxLines && lines >= maxLines) return;
    } else {
      line = testLine;
    }
  }
  if(line && (!maxLines || lines < maxLines)){
    ctx.fillText(line, x, y + lines*lineHeight);
  }
}

/** -------------------------------------------------------
 *  Events
 * ------------------------------------------------------*/
const canvas = document.getElementById('c');

function canvasPos(evt){
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: (evt.clientX - rect.left) * scaleX,
    y: (evt.clientY - rect.top) * scaleY
  };
}

canvas.addEventListener('mousedown', (ev) => {
  const mode = document.getElementById('legendMode').value;
  if(mode !== 'free') return;
  const p = canvasPos(ev);
  if(pointInLegend(p.x, p.y)){
    legendState.dragging = True = true;
    legendState.dragDx = p.x - legendState.x;
    legendState.dragDy = p.y - legendState.y;
    ev.preventDefault();
  }
});

canvas.addEventListener('mousemove', (ev) => {
  if(!legendState.dragging) return;
  const p = canvasPos(ev);
  legendState.x = clamp(p.x - legendState.dragDx, 0, legendBounds(canvas).maxX);
  legendState.y = clamp(p.y - legendState.dragDy, 0, legendBounds(canvas).maxY);
  legendToSliders(canvas);
  render(); // simple redraw
});

window.addEventListener('mouseup', () => { legendState.dragging = false; });

document.getElementById('legendX').addEventListener('input', () => { slidersToLegend(canvas); render(); });
document.getElementById('legendY').addEventListener('input', () => { slidersToLegend(canvas); render(); });
document.getElementById('legendMode').addEventListener('change', () => { render(); });

document.getElementById('formatSelect').addEventListener('change', () => { render(); });
document.getElementById('btnRender').addEventListener('click', () => { render(); });

document.getElementById('btnResetLegend').addEventListener('click', () => {
  const c = document.getElementById('c');
  legendDefaultSize(c);
  legendState.x = 40; legendState.y = 40;
  legendToSliders(c);
  render();
});

document.getElementById('btnDownload').addEventListener('click', () => {
  const c = document.getElementById('c');
  const a = document.createElement('a');
  a.download = 'poster.png';
  a.href = c.toDataURL('image/png');
  a.click();
});

// Initial
try{ render(); }catch(e){ console.error(e); setStatus("Error inicial: " + (e?.message||e), "warn"); }
</script>
</body>
</html>
